//최대 범위가 2의 31승이므로 범위가 매우 크기 때문에 반복문으로 해결하려고 할 경우 시간초과가 발생하는 문제이다.
//또한, int형이 표현할 수 있는 최대 범위를 넘어서므로 long long 자료형으로 변수를 선언해주어야한다.
//
//먼저 이 문제의 규칙을 알아보자.
//
//마지막에는 반드시 1광년을 이동해야 하므로, k광년 이동시, k - 1, k, k + 1광년만 이동할 수 있다는 제약 조건에 의해, 마지막 이동 전에는 최대 2광년 이동이 가능하다.또한, 최대 2광년이므로, 그 이전의 이동은 최대 3광년까지만 가능하다.
//
//이러한 규칙에 의해서 최대거리를 이동하기 위해서는,
//1광년이동 -> 2광년이동 -> 1광년이동(마지막이동)
//1광년이동 -> 2광년이동 -> 3광년이동 -> 2광년이동 -> 1광년이동(마지막이동)
//의 규칙을 따라야 한다.
//
//1 + 2 + 1 = 4(최대이동거리) = 2 X 2(최대 속도 N = 2), 이동 횟수 = 3번
//1 + 2 + 3 + 2 + 1 = 9(최대이동거리) = 3 X 3(최대 속도 N = 3), 이동 횟수 = 5번
//1 + 2 + 3 + 4 + 3 + 2 + 1 = 16(최대이동거리) = 4 X 4(최대 속도 N = 4), 이동 횟수 = 7번
//의 규칙을 가지게 된다.
//
//따라서 최소의 차원이동을 하기 위해서는 우선 최대 이동거리만큼 이동을 하고, 모자란 거리 만큼을 중간에 넣어주면 된다.
//
//예를 들어
//11광년을 이동해야 한다면 먼저 1 - 2 - 3 - 2 - 1 로 9광년을 이동한다고 가정 한 후, 아래와 같이 규칙을 어기지 않는 선에서 남은 2광년에 해당하는 수를 끼워넣어주면 된다.
//1 - 2 - 3 - 2 - 2 - 1 즉 총 6번의 이동을 통해 이동 할 수 있다.
//
//하지만 만약, 최대이동거리인 9광년을 이동한 후, 남은 광년이 최대 속도인  N = 3을 넘기는 경우에는 어떻게 해결할 수 있을까 ? 마찬가지로 13광년을 이동해야 할 경우, 1 - 2 - 3 - 2 - 1 로 9광년을 이동한다고 가정 한 후, 4광년 만큼을 끼워 넣어주면 된다.
//1 - 2 - 3 - 3 - 2 - 1 - 1 혹은, 1 - 2 - 3 - 2 - 2 - 2 - 1 식으로 바꿔 총 7번의 이동을 통해 이동할 수 있다.

#include <iostream>
#include <cmath>

using namespace std;

int main() {
    int num;
    
    cin >> num;

    for (int i = 0; i < num; i++)
    {
        long long x, y, gap, rem;
        long long move, max = 0;

        cin >> x >> y;

        gap = y - x;

        while (max * max <= gap)  // for문이 아닌 while문을 써서 max값을 찾는다.
            ++max;
        --max;

        move = 2 * max - 1;     // 광년 (전체 움직인 거리) 계산
        rem = gap - max * max;
        rem = (long long)ceil((double)rem / (double)max);   // ceil(int x)함수는 나눈 후 올림처리. floor(int x)함수는 나눈 후 내림처리. round(int x)는 반올림.
        move += rem;

        cout << move << '\n';
    }
}
